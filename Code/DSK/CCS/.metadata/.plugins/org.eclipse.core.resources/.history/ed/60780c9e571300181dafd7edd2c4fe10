/*
 * functions.c
 *
 *  Created on: 16 févr. 2018
 *      Author: pascal
 */

#include "functions.h"


//for FFT implementation
#define MAX 200
#define M_PI 3.1415926535897932384




//--------------------------------------------
//  UTILS FUNCTIONS
//--------------------------------------------

//float element wise vector multiplication
void fvec_elementWise_mult(float *a, float *b, float *dest, int size) {

    int i;
    for(i = 0; i < size; i++) {

        dest[i] = a[i] * b[i];
    }
}



//--------------------------------------------
//  HAMMING WINDOW
//--------------------------------------------
//apply hamming window to a signal
void mfcc_hamming_window_256(float *x) {

    static const float hamming_window[256] = {0.08,0.080139632,0.080558444,0.08125618,0.082232418,0.083486566,0.08501786,0.086825373,0.088908006,0.091264495,0.093893409,0.096793154,0.099961967,0.103397926,0.107098944,0.111062774,0.115287011,0.119769089,0.124506288,0.129495732,0.134734391,0.140219085,0.145946484,0.151913112,0.158115346,0.16454942,0.171211429,0.178097329,0.185202937,0.192523942,0.200055898,0.207794233,0.215734248,0.223871124,0.232199921,0.240715582,0.249412937,0.258286707,0.267331503,0.276541836,0.285912112,0.295436645,0.305109651,0.314925258,0.324877507,0.334960356,0.345167684,0.355493294,0.365930917,0.376474217,0.387116792,0.397852183,0.40867387,0.419575286,0.43054981,0.441590782,0.452691497,0.463845217,0.47504517,0.486284557,0.497556555,0.508854319,0.520170992,0.531499704,0.542833575,0.554165727,0.565489278,0.576797356,0.588083093,0.59933964,0.610560161,0.621737846,0.632865908,0.643937592,0.654946175,0.665884975,0.676747351,0.687526708,0.698216503,0.708810244,0.719301502,0.729683906,0.739951154,0.750097012,0.760115322,0.77,0.779745046,0.789344544,0.798792666,0.808083676,0.817211933,0.826171896,0.834958125,0.843565286,0.851988154,0.860221615,0.868260671,0.876100441,0.883736166,0.89116321,0.898377064,0.905373349,0.912147817,0.918696356,0.92501499,0.931099882,0.93694734,0.942553812,0.947915896,0.953030335,0.957894025,0.962504013,0.966857501,0.970951846,0.974784561,0.97835332,0.981655957,0.984690466,0.987455005,0.989947896,0.992167626,0.994112846,0.995782376,0.997175203,0.99829048,0.999127531,0.999685848,0.999965091,0.999965091,0.999685848,0.999127531,0.99829048,0.997175203,0.995782376,0.994112846,0.992167626,0.989947896,0.987455005,0.984690466,0.981655957,0.97835332,0.974784561,0.970951846,0.966857501,0.962504013,0.957894025,0.953030335,0.947915896,0.942553812,0.93694734,0.931099882,0.92501499,0.918696356,0.912147817,0.905373349,0.898377064,0.89116321,0.883736166,0.876100441,0.868260671,0.860221615,0.851988154,0.843565286,0.834958125,0.826171896,0.817211933,0.808083676,0.798792666,0.789344544,0.779745046,0.77,0.760115322,0.750097012,0.739951154,0.729683906,0.719301502,0.708810244,0.698216503,0.687526708,0.676747351,0.665884975,0.654946175,0.643937592,0.632865908,0.621737846,0.610560161,0.59933964,0.588083093,0.576797356,0.565489278,0.554165727,0.542833575,0.531499704,0.520170992,0.508854319,0.497556555,0.486284557,0.47504517,0.463845217,0.452691497,0.441590782,0.43054981,0.419575286,0.40867387,0.397852183,0.387116792,0.376474217,0.365930917,0.355493294,0.345167684,0.334960356,0.324877507,0.314925258,0.305109651,0.295436645,0.285912112,0.276541836,0.267331503,0.258286707,0.249412937,0.240715582,0.232199921,0.223871124,0.215734248,0.207794233,0.200055898,0.192523942,0.185202937,0.178097329,0.171211429,0.16454942,0.158115346,0.151913112,0.145946484,0.140219085,0.134734391,0.129495732,0.124506288,0.119769089,0.115287011,0.111062774,0.107098944,0.103397926,0.099961967,0.096793154,0.093893409,0.091264495,0.088908006,0.086825373,0.08501786,0.083486566,0.082232418,0.08125618,0.080558444,0.080139632,0.08};
    int i;

    for(i = 0; i < 256; i++) {

        x[i] = x[i] * hamming_window[i];
    }
}

//optimized function
void mfcc_hamming_window_256_opt(float *x) {

    static const float hamming_window[256] = {0.08,0.080139632,0.080558444,0.08125618,0.082232418,0.083486566,0.08501786,0.086825373,0.088908006,0.091264495,0.093893409,0.096793154,0.099961967,0.103397926,0.107098944,0.111062774,0.115287011,0.119769089,0.124506288,0.129495732,0.134734391,0.140219085,0.145946484,0.151913112,0.158115346,0.16454942,0.171211429,0.178097329,0.185202937,0.192523942,0.200055898,0.207794233,0.215734248,0.223871124,0.232199921,0.240715582,0.249412937,0.258286707,0.267331503,0.276541836,0.285912112,0.295436645,0.305109651,0.314925258,0.324877507,0.334960356,0.345167684,0.355493294,0.365930917,0.376474217,0.387116792,0.397852183,0.40867387,0.419575286,0.43054981,0.441590782,0.452691497,0.463845217,0.47504517,0.486284557,0.497556555,0.508854319,0.520170992,0.531499704,0.542833575,0.554165727,0.565489278,0.576797356,0.588083093,0.59933964,0.610560161,0.621737846,0.632865908,0.643937592,0.654946175,0.665884975,0.676747351,0.687526708,0.698216503,0.708810244,0.719301502,0.729683906,0.739951154,0.750097012,0.760115322,0.77,0.779745046,0.789344544,0.798792666,0.808083676,0.817211933,0.826171896,0.834958125,0.843565286,0.851988154,0.860221615,0.868260671,0.876100441,0.883736166,0.89116321,0.898377064,0.905373349,0.912147817,0.918696356,0.92501499,0.931099882,0.93694734,0.942553812,0.947915896,0.953030335,0.957894025,0.962504013,0.966857501,0.970951846,0.974784561,0.97835332,0.981655957,0.984690466,0.987455005,0.989947896,0.992167626,0.994112846,0.995782376,0.997175203,0.99829048,0.999127531,0.999685848,0.999965091,0.999965091,0.999685848,0.999127531,0.99829048,0.997175203,0.995782376,0.994112846,0.992167626,0.989947896,0.987455005,0.984690466,0.981655957,0.97835332,0.974784561,0.970951846,0.966857501,0.962504013,0.957894025,0.953030335,0.947915896,0.942553812,0.93694734,0.931099882,0.92501499,0.918696356,0.912147817,0.905373349,0.898377064,0.89116321,0.883736166,0.876100441,0.868260671,0.860221615,0.851988154,0.843565286,0.834958125,0.826171896,0.817211933,0.808083676,0.798792666,0.789344544,0.779745046,0.77,0.760115322,0.750097012,0.739951154,0.729683906,0.719301502,0.708810244,0.698216503,0.687526708,0.676747351,0.665884975,0.654946175,0.643937592,0.632865908,0.621737846,0.610560161,0.59933964,0.588083093,0.576797356,0.565489278,0.554165727,0.542833575,0.531499704,0.520170992,0.508854319,0.497556555,0.486284557,0.47504517,0.463845217,0.452691497,0.441590782,0.43054981,0.419575286,0.40867387,0.397852183,0.387116792,0.376474217,0.365930917,0.355493294,0.345167684,0.334960356,0.324877507,0.314925258,0.305109651,0.295436645,0.285912112,0.276541836,0.267331503,0.258286707,0.249412937,0.240715582,0.232199921,0.223871124,0.215734248,0.207794233,0.200055898,0.192523942,0.185202937,0.178097329,0.171211429,0.16454942,0.158115346,0.151913112,0.145946484,0.140219085,0.134734391,0.129495732,0.124506288,0.119769089,0.115287011,0.111062774,0.107098944,0.103397926,0.099961967,0.096793154,0.093893409,0.091264495,0.088908006,0.086825373,0.08501786,0.083486566,0.082232418,0.08125618,0.080558444,0.080139632,0.08};
    int i;

    for(i = 0; i < 256; i+=8) {

        //force the DSP to do 2 multiplication in parallel and use 8 parallel adder
        x[i]   = x[i]   * hamming_window[i];
        x[i+1] = x[i+1] * hamming_window[i+1];
        x[i+2] = x[i+2] * hamming_window[i+2];
        x[i+3] = x[i+3] * hamming_window[i+3];
        x[i+4] = x[i+4] * hamming_window[i+4];
        x[i+5] = x[i+5] * hamming_window[i+5];
        x[i+6] = x[i+6] * hamming_window[i+6];
        x[i+7] = x[i+7] * hamming_window[i+7];
    }
}






//--------------------------------------------
//  FAST FOURIER TRANSFORM (FFT)
//--------------------------------------------
/*
int log2(int N) {    //function to calculate the log2(.) of int numbers

  int k = N, i = 0;
  while(k) {
    k >>= 1;
    i++;
  }
  return i - 1;
}

int check(int n) {    //checking if the number of element is a power of 2

  return n > 0 && (n & (n - 1)) == 0;
}

int reverse(int N, int n) {  //calculating revers number

  int j, p = 0;
  for(j = 1; j <= log2(N); j++) {
    if(n & (1 << (log2(N) - j)))
      p |= 1 << (j - 1);
  }
  return p;
}

void ordina(complex<float>* f1, int N) {//using the reverse order in the array

  complex<float> f2[MAX];
  for(int i = 0; i < N; i++)
    f2[i] = f1[reverse(N, i)];
  for(int j = 0; j < N; j++)
    f1[j] = f2[j];
}

void transform(complex<float>* f, int N) {//

  ordina(f, N);    //first: reverse order
  complex<float> *W;
  W = (complex<float> *)malloc(N / 2 * sizeof(complex<float>));
  W[1] = polar(1., -2. * M_PI / N);
  W[0] = 1;
  for(int i = 2; i < N / 2; i++)
    W[i] = pow(W[1], i);
  int n = 1;
  int a = N / 2;
  for(int j = 0; j < log2(N); j++) {
    for(int i = 0; i < N; i++) {
      if(!(i & n)) {
        complex<float> temp = f[i];
        complex<float> Temp = W[(i * a) % (n * a)] * f[i + n];
        f[i] = temp + Temp;
        f[i + n] = temp - Temp;
      }
    }
    n *= 2;
    a = a / 2;
  }
}

void FFT(complex<float>* f, float d, int N) {

  transform(f, N);
  for(int i = 0; i < N; i++) {
    f[i] *= d; //multiplying by step<
  }
}
*/



